(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{296:function(v,e,_){"use strict";_.r(e);var t=_(0),s=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("关于JavaScript的各种概念的总结.")]),v._v(" "),_("h2",{attrs:{id:"class"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[v._v("#")]),v._v(" Class")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("类(Class)：定义了一件事物的抽象特点，包含它的属性和方法")])]),v._v(" "),_("li",[_("p",[v._v("对象（Object）：类的实例，通过 "),_("code",[v._v("new")]),v._v(" 生成")])]),v._v(" "),_("li",[_("p",[v._v("面向对象（OOP）的三大特性：封装、继承、多态")])]),v._v(" "),_("li",[_("p",[v._v("封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据")])]),v._v(" "),_("li",[_("p",[v._v("继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性")])]),v._v(" "),_("li",[_("p",[v._v("多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 "),_("code",[v._v("Cat")]),v._v(" 和 "),_("code",[v._v("Dog")]),v._v(" 都继承自 "),_("code",[v._v("Animal")]),v._v("，但是分别实现了自己的 "),_("code",[v._v("eat")]),v._v(" 方法。此时针对某一个实例，我们无需了解它是 "),_("code",[v._v("Cat")]),v._v(" 还是 "),_("code",[v._v("Dog")]),v._v("，就可以直接调用 "),_("code",[v._v("eat")]),v._v(" 方法，程序会自动判断出来应该如何执行 "),_("code",[v._v("eat")])])]),v._v(" "),_("li",[_("p",[v._v("存取器（getter & setter）：用以改变属性的读取和赋值行为")])]),v._v(" "),_("li",[_("p",[v._v("修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 "),_("code",[v._v("public")]),v._v(" 表示公有属性或方法")])]),v._v(" "),_("li",[_("p",[v._v("抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现")])]),v._v(" "),_("li",[_("p",[v._v("接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);